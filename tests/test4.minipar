# Rede Neural para aprender a função XOR com uma camada oculta de 3 neurônios

func sigmoid(x: number) -> number {
    return 1 / (1 + math.exp(-x))
}

func sigmoid_derivative(x: number) -> number {
    return x * (1 - x)
}

class Neuronio {
    var pesos: list
    var bias: number
    var saida: number

    func init(num_inputs: number) -> void {
        self.pesos = []
        for (var i: number = 0 in num_inputs) {
            self.pesos.append(random.random())
        }
        self.bias = random.random()
        self.saida = 0
    }

    func feedforward(entradas: list) -> number {
        var soma: number = 0
        for (var i: number = 0 in entradas.length) {
            soma = soma + entradas[i] * self.pesos[i]
        }
        soma = soma + self.bias
        self.saida = sigmoid(soma)
        return self.saida
    }

    func calcular_derivada() -> number {
        return sigmoid_derivative(self.saida)
    }
}

class RedeNeural {
    var taxa_aprendizado: number
    var camada_oculta: list
    var neuronio_saida: Neuronio

    func init(taxa_aprendizado: number) -> void {
        self.taxa_aprendizado = taxa_aprendizado
        self.camada_oculta = []
        for (var i: number = 0 in 3) {
            self.camada_oculta.append(new Neuronio(2))
        }
        self.neuronio_saida = new Neuronio(3)
    }

    func feedforward(entradas: list) -> (list, number) {
        var saidas_ocultas: list = []
        for (var i: number = 0 in self.camada_oculta.length) {
            saidas_ocultas.append(self.camada_oculta[i].feedforward(entradas))
        }
        var saida_final: number = self.neuronio_saida.feedforward(saidas_ocultas)
        return (saidas_ocultas, saida_final)
    }

    func backpropagation(entradas: list, saida_desejada: number, saidas_ocultas: list, saida_final: number) -> void {
        var erro: number = saida_desejada - saida_final
        var delta_saida: number = erro * self.neuronio_saida.calcular_derivada()
        # Atualiza pesos da camada de saída
        for (var i: number = 0 in self.neuronio_saida.pesos.length) {
            self.neuronio_saida.pesos[i] = self.neuronio_saida.pesos[i] + saidas_ocultas[i] * delta_saida * self.taxa_aprendizado
        }
        self.neuronio_saida.bias = self.neuronio_saida.bias + delta_saida * self.taxa_aprendizado
        # Atualiza pesos da camada oculta
        for (var i: number = 0 in self.camada_oculta.length) {
            var neuronio: Neuronio = self.camada_oculta[i]
            var delta_oculto: number = delta_saida * self.neuronio_saida.pesos[i] * neuronio.calcular_derivada()
            for (var j: number = 0 in neuronio.pesos.length) {
                neuronio.pesos[j] = neuronio.pesos[j] + entradas[j] * delta_oculto * self.taxa_aprendizado
            }
            neuronio.bias = neuronio.bias + delta_oculto * self.taxa_aprendizado
        }
    }

    func treinar(entradas: list, saidas_desejadas: list, epocas: number) -> void {
        for (var epoca: number = 0 in epocas) {
            for (var i: number = 0 in entradas.length) {
                var entrada: list = entradas[i]
                var saida_desejada: number = saidas_desejadas[i]
                var (saidas_ocultas, saida_final) = self.feedforward(entrada)
                self.backpropagation(entrada, saida_desejada, saidas_ocultas, saida_final)
            }
        }
    }

    func testar(entradas: list) -> void {
        for (var i: number = 0 in entradas.length) {
            var entrada: list = entradas[i]
            var (_, saida_final) = self.feedforward(entrada)
            print("Input: " + entrada + ", Predicted Output: " + saida_final)
        }
    }
}

seq {
    var entradas: list = [[0, 0], [0, 1], [1, 0], [1, 1]]
    var saidas_desejadas: list = [0, 1, 1, 0]
    var rede: RedeNeural = new RedeNeural(0.2)
    rede.treinar(entradas, saidas_desejadas, 20000)
    rede.testar(entradas)
}